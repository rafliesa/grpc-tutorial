# Reflection

## 1. What are the key differences between unary, server streaming, and bi-directional streaming RPC (Remote Procedure Call) methods, and in what scenarios would each be most suitable?
Unary, server streaming, dan bidirectional streaming RPC memiliki perbedaan mendasar dalam pola komunikasi antara klien dan server. Unary RPC melibatkan satu permintaan dan satu respons, cocok untuk operasi yang sederhana dan cepat seperti permintaan data spesifik atau eksekusi transaksi tunggal. Server streaming RPC memungkinkan klien mengirim satu permintaan dan server mengirimkan serangkaian respons secara bertahap, yang ideal untuk kasus seperti notifikasi berkala, pemantauan log, atau aliran data besar. Sebaliknya, bidirectional streaming RPC memungkinkan klien dan server saling mengirimkan pesan secara independen dan simultan, sangat sesuai untuk aplikasi real-time seperti obrolan daring, kolaborasi dokumen, atau permainan daring yang interaktif.

## 2. What are the potential security considerations involved in implementing a gRPC service in Rust, particularly regarding authentication, authorization, and data encryption?
Dalam mengimplementasikan layanan gRPC dengan Rust, terdapat sejumlah pertimbangan keamanan penting yang perlu diperhatikan, terutama dalam aspek autentikasi, otorisasi, dan enkripsi data. Autentikasi dapat dilakukan dengan menerapkan TLS (Transport Layer Security) berbasis sertifikat atau melalui token seperti OAuth2 dan JWT (JSON Web Token) untuk memastikan identitas klien dan server. Otorisasi harus diatur dengan kontrol akses berbasis peran (role-based access control) agar hanya pengguna yang berwenang dapat mengakses layanan atau metode tertentu. Enkripsi data selama transmisi menggunakan TLS wajib diterapkan untuk menjaga kerahasiaan dan integritas data. Di samping itu, validasi input yang masuk juga menjadi aspek krusial untuk mencegah serangan seperti injection atau manipulasi data berbahaya.

## 3. What are the potential challenges or issues that may arise when handling bidirectional streaming in Rust gRPC, especially in scenarios like chat applications?
Dalam skenario seperti aplikasi chat yang menggunakan bidirectional streaming pada Rust gRPC, terdapat sejumlah tantangan teknis yang perlu diantisipasi. Salah satu tantangan utama adalah pengelolaan konkurensi asinkron karena klien dan server dapat mengirim data secara bersamaan, sehingga perlu penerapan task yang efisien dan tidak saling memblokir. Selain itu, pengelolaan status koneksi secara real-time menjadi kompleks, terutama jika banyak klien terhubung secara simultan, sehingga memerlukan strategi pengelolaan state yang skalabel dan aman. Masalah lain yang dapat muncul adalah potensi kehilangan pesan atau ketidakterurutan data, sehingga perlu mekanisme buffer, retry, atau penandaan pesan untuk menjamin konsistensi komunikasi.

## 4. What are the advantages and disadvantages of using the tokio_stream::wrappers::ReceiverStream for streaming responses in Rust gRPC services?
Penggunaan tokio_stream::wrappers::ReceiverStream untuk menangani streaming respons dalam layanan gRPC di Rust menawarkan sejumlah kelebihan dan kekurangan. Keuntungannya terletak pada kemudahan integrasi dengan sistem asinkron berbasis Tokio, memungkinkan pengelolaan data yang datang dari channel dengan cara yang lebih idiomatik di Rust. Selain itu, pendekatan ini relatif ringan dan fleksibel untuk digunakan dalam skenario streaming data dinamis. Namun, kelemahannya termasuk potensi bottleneck jika data yang dikirim lebih cepat dari yang dapat dikonsumsi oleh receiver, serta kebutuhan manajemen buffer yang hati-hati untuk menghindari kehilangan data atau deadlock. Selain itu, penggunaan channel dapat menambah kompleksitas jika tidak dikelola secara efisien dalam aplikasi yang besar.

## 5. In what ways could the Rust gRPC code be structured to facilitate code reuse and modularity, promoting maintainability and extensibility over time
Agar kode gRPC dalam Rust lebih modular dan mudah digunakan kembali, perlu penerapan struktur proyek yang jelas dan terpisah antar komponen. Logika bisnis sebaiknya dipisahkan dari implementasi handler RPC agar kode lebih bersih dan dapat diuji secara terpisah. Protokol dan definisi layanan dalam file .proto sebaiknya diorganisasi dengan namespace yang tepat untuk mendukung skalabilitas. Setiap fungsionalitas tambahan seperti otentikasi, logging, database, atau validasi input dapat diimplementasikan dalam modul terpisah atau crate internal, sehingga memudahkan pengembangan jangka panjang dan mendorong praktik pengujian unit secara independen. Dengan pendekatan ini, sistem menjadi lebih terstruktur, mudah dipelihara, dan dapat dikembangkan kembali tanpa mengganggu keseluruhan sistem.

## 6. In the MyPaymentService implementation, what additional steps might be necessary to handle more complex payment processing logic?
Dalam implementasi MyPaymentService, penanganan logika pembayaran yang lebih kompleks membutuhkan beberapa langkah tambahan agar transaksi berjalan aman dan akurat. Hal ini mencakup validasi berlapis terhadap data transaksi seperti nomor kartu, jumlah pembayaran, dan status akun pengguna. Selain itu, transaksi harus bersifat atomik dengan sistem penyimpanan, agar data tidak berada dalam kondisi setengah jadi saat terjadi kegagalan. Integrasi dengan layanan pihak ketiga seperti gateway pembayaran, notifikasi email, dan audit log juga menjadi bagian penting dari sistem. Di sisi lain, sistem juga harus mampu mendeteksi potensi penipuan, seperti pembayaran ganda atau manipulasi nominal, yang dapat ditangani melalui penerapan sistem verifikasi tambahan dan audit log.

## 7. What impact does the adoption of gRPC as a communication protocol have on the overall architecture and design of distributed systems, particularly in terms of interoperability with other technologies and platforms?
Adopsi gRPC sebagai protokol komunikasi memberikan pengaruh signifikan terhadap arsitektur sistem terdistribusi, terutama dalam hal interoperabilitas dan efisiensi komunikasi antar layanan. gRPC mendukung berbagai bahasa pemrograman, memungkinkan tim lintas teknologi untuk bekerja secara terpadu dengan protokol yang sama. Dengan menggunakan Protocol Buffers sebagai format pesan, ukuran data menjadi lebih kecil dan kecepatan parsing meningkat dibanding JSON, yang sangat bermanfaat dalam layanan dengan trafik tinggi. Namun, gRPC memerlukan infrastruktur tambahan seperti HTTP/2, serta skema eksplisit yang membuat integrasi dengan sistem yang tidak mendukung gRPC secara langsung menjadi lebih menantang. Untuk itu, kadang diperlukan gateway REST tambahan agar gRPC dapat berkomunikasi dengan layanan lama.

## 8. What are the advantages and disadvantages of using HTTP/2, the underlying protocol for gRPC, compared to HTTP/1.1 or HTTP/1.1 with WebSocket for REST APIs?
HTTP/2 sebagai protokol dasar gRPC memiliki banyak kelebihan dibanding HTTP/1.1, terutama dalam hal performa dan efisiensi. Fitur seperti multiplexing memungkinkan banyak permintaan dan respons dikirimkan melalui satu koneksi TCP tanpa blocking, mengurangi latensi secara signifikan. Kompresi header juga membantu mengurangi ukuran data, yang berdampak positif pada efisiensi bandwidth. Namun, HTTP/2 juga memiliki kelemahan seperti kompleksitas implementasi dan ketergantungan pada TLS, yang bisa menjadi hambatan pada jaringan atau sistem lama. Sementara WebSocket di HTTP/1.1 menawarkan komunikasi dua arah, ia tidak memiliki struktur dan validasi bawaan seperti pada gRPC, sehingga keamanan dan format pesan perlu diatur secara manual.

## 9. How does the request-response model of REST APIs contrast with the bidirectional streaming capabilities of gRPC in terms of real-time communication and responsiveness?
Model permintaan dan respons pada REST API umumnya bersifat sinkron dan stateless, yang berarti setiap permintaan harus menunggu satu respons sebelum mengirim permintaan berikutnya. Hal ini membuat REST kurang ideal untuk aplikasi yang membutuhkan komunikasi real-time atau respons yang cepat dan terus-menerus. Sebaliknya, gRPC mendukung bidirectional streaming yang memungkinkan klien dan server saling mengirim data secara paralel tanpa menunggu giliran, sehingga jauh lebih responsif untuk aplikasi seperti dashboard pemantauan langsung atau kolaborasi daring. Dengan demikian, gRPC lebih unggul dalam skenario yang memerlukan aliran data kontinu dan interaksi interaktif secara langsung.

## 10.  What are the implications of the schema-based approach of gRPC, using Protocol Buffers, compared to the more flexible, schema-less nature of JSON in REST API payloads?
Pendekatan berbasis skema pada gRPC melalui Protocol Buffers memberikan keuntungan dalam hal konsistensi data, deteksi kesalahan sejak awal, serta efisiensi dalam serialisasi dan deserialisasi pesan. Setiap perubahan pada struktur data harus dinyatakan secara eksplisit dalam skema .proto, yang membantu menjaga kontrak antara klien dan server tetap jelas. Namun, ini juga mengurangi fleksibilitas karena setiap perubahan memerlukan regenerasi kode dan penyebaran ulang. Di sisi lain, REST API dengan JSON bersifat lebih fleksibel dan dapat menangani data dengan struktur dinamis, tetapi rentan terhadap kesalahan karena tidak ada validasi skema otomatis, yang dapat menyebabkan kesalahan parsing atau interpretasi data jika tidak ditangani dengan benar.